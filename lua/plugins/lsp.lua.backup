return {
  "neovim/nvim-lspconfig",
  event = { "BufReadPre", "BufNewFile" },
  config = function()
    local lspconfig = require("lspconfig")
    -- Get capabilities from blink.cmp
    local capabilities = require("blink.cmp").get_lsp_capabilities()

    -- Performance optimized LSP settings
    local default_config = {
      capabilities = capabilities,
      flags = {
        debounce_text_changes = 150,
      },
    }

    -- TypeScript/JavaScript with vtsls - comprehensive settings
    lspconfig.vtsls.setup(vim.tbl_extend("force", default_config, {
      filetypes = {
        "javascript",
        "javascriptreact",
        "javascript.jsx",
        "typescript",
        "typescriptreact",
        "typescript.tsx",
        "vue"
      },
      settings = {
        complete_function_calls = true,
        vtsls = {
          enableMoveToFileCodeAction = true,
          autoUseWorkspaceTsdk = true,
          experimental = {
            maxInlayHintLength = 30,
            completion = {
              enableServerSideFuzzyMatch = true,
            },
          },
        },
        typescript = {
          globalPlugins = {
            {
              name = "@angular/language-service",
              location = vim.fs.normalize("node_modules/@angular/language-service"),
              enableForWorkspaceTypeScriptVersions = false,
            },
          },
          updateImportsOnFileMove = { enabled = "always" },
          suggest = {
            completeFunctionCalls = true,
            autoImports = true,
            includeCompletionsForModuleExports = true,
          },
        typescript = {
          updateImportsOnFileMove = { enabled = "always" },
          suggest = {
            completeFunctionCalls = true,
            autoImports = true,
            includeCompletionsForModuleExports = true,
          },
          preferences = {
            importModuleSpecifier = "relative",
            includePackageJsonAutoImports = "on",
          },
          inlayHints = {
            enumMemberValues = { enabled = true },
            functionLikeReturnTypes = { enabled = true },
            parameterNames = { enabled = "literals" },
            parameterTypes = { enabled = true },
            variableTypes = { enabled = false },
            propertyDeclarationTypes = { enabled = true }
          },
          format = {
            enable = true,
            semicolons = "insert",
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces = true,
            insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces = false,
          },
          workspaceSymbols = {
            scope = "allOpenProjects",
          },
        },
        javascript = {
          updateImportsOnFileMove = { enabled = "always" },
          suggest = {
            completeFunctionCalls = true,
            autoImports = true,
            includeCompletionsForModuleExports = true,
          },
          preferences = {
            importModuleSpecifier = "relative",
            includePackageJsonAutoImports = "on",
          },
          inlayHints = {
            enumMemberValues = { enabled = true },
            functionLikeReturnTypes = { enabled = true },
            parameterNames = { enabled = "literals" },
            parameterTypes = { enabled = true },
            variableTypes = { enabled = false },
            propertyDeclarationTypes = { enabled = true }
          },
          format = {
            enable = true,
            semicolons = "insert",
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces = true,
            insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces = false,
          },
        },
      }
    }))

    -- Python with basedpyright
    lspconfig.basedpyright.setup(default_config)

    -- Rust with comprehensive rust-analyzer settings
    lspconfig.rust_analyzer.setup(vim.tbl_extend("force", default_config, {
      settings = {
        ["rust-analyzer"] = {
          imports = {
            granularity = {
              group = "module",
            },
            prefix = "self",
          },
          cargo = {
            buildScripts = {
              enable = true,
            },
          },
          procMacro = {
            enable = true,
          },
          diagnostics = {
            enable = true,
            experimental = {
              enable = true,
            },
          },
          checkOnSave = {
            command = "clippy",
            extraArgs = { "--no-deps" },
          },
          inlayHints = {
            bindingModeHints = {
              enable = false,
            },
            chainingHints = {
              enable = true,
            },
            closingBraceHints = {
              enable = true,
              minLines = 25,
            },
            closureReturnTypeHints = {
              enable = "never",
            },
            lifetimeElisionHints = {
              enable = "never",
              useParameterNames = false,
            },
            maxLength = 25,
            parameterHints = {
              enable = true,
            },
            reborrowHints = {
              enable = "never",
            },
            renderColons = true,
            typeHints = {
              enable = true,
              hideClosureInitialization = false,
              hideNamedConstructor = false,
            },
          },
          lens = {
            enable = true,
          },
          hover = {
            actions = {
              enable = true,
            },
          },
        },
      },
    }))

    -- Flutter/Dart LSP with enhanced settings
    lspconfig.dartls.setup(vim.tbl_extend("force", default_config, {
      cmd = { "dart", "language-server", "--protocol=lsp" },
      filetypes = { "dart" },
      root_dir = lspconfig.util.root_pattern("pubspec.yaml", ".git"),
      init_options = {
        onlyAnalyzeProjectsWithOpenFiles = false,
        suggestFromUnimportedLibraries = true,
        closingLabels = true,
        outline = true,
        flutterOutline = true,
      },
      settings = {
        dart = {
          completeFunctionCalls = true,
          showTodos = true,
          renameFilesWithClasses = "prompt",
          updateImportsOnRename = true,
          insertArgumentPlaceholders = true,
          analysisExcludedFolders = {
            vim.fn.expand("$HOME/AppData/Local/Pub/Cache"),
            vim.fn.expand("$HOME/.pub-cache"),
            vim.fn.expand("/opt/homebrew/"),
            vim.fn.expand("$HOME/tools/flutter/"),
            ".dart_tool",
            "build",
          },
          enableSdkFormatter = true,
          lineLength = 80,
          enableSnippets = true,
        },
      },
      on_attach = function(client, bufnr)
        -- Use localleader (\) for Flutter-specific commands
        vim.keymap.set("n", "<localleader>r", ":FlutterReload<CR>", { buffer = bufnr, desc = "Flutter Hot Reload" })
        vim.keymap.set("n", "<localleader>R", ":FlutterRestart<CR>", { buffer = bufnr, desc = "Flutter Hot Restart" })
        vim.keymap.set("n", "<localleader>q", ":FlutterQuit<CR>", { buffer = bufnr, desc = "Flutter Quit" })
        vim.keymap.set("n", "<localleader>d", ":FlutterDevices<CR>", { buffer = bufnr, desc = "Flutter Devices" })
        vim.keymap.set("n", "<localleader>l", ":FlutterLog<CR>", { buffer = bufnr, desc = "Flutter Logs" })
        vim.keymap.set("n", "<localleader>c", ":FlutterLogClear<CR>", { buffer = bufnr, desc = "Clear Flutter Logs" })
        vim.keymap.set("n", "<localleader>p", ":FlutterPubGet<CR>", { buffer = bufnr, desc = "Flutter Pub Get" })
        vim.keymap.set("n", "<localleader>u", ":FlutterPubUpgrade<CR>", { buffer = bufnr, desc = "Flutter Pub Upgrade" })

        -- Create Flutter commands
        vim.api.nvim_buf_create_user_command(bufnr, "FlutterReload", function()
          vim.notify("Flutter Hot Reload triggered", vim.log.levels.INFO)
          vim.fn.system("kill -USR1 $(pgrep -f flutter_runner)")
        end, {})

        vim.api.nvim_buf_create_user_command(bufnr, "FlutterRestart", function()
          vim.notify("Flutter Hot Restart triggered", vim.log.levels.INFO)
          vim.fn.system("kill -USR2 $(pgrep -f flutter_runner)")
        end, {})

        vim.api.nvim_buf_create_user_command(bufnr, "FlutterQuit", function()
          vim.notify("Flutter app quit", vim.log.levels.INFO)
          vim.fn.system("kill -QUIT $(pgrep -f flutter_runner)")
        end, {})

        vim.api.nvim_buf_create_user_command(bufnr, "FlutterDevices", function()
          local output = vim.fn.system("flutter devices")
          vim.notify(output, vim.log.levels.INFO)
        end, {})

        -- Flutter log viewer in a new terminal
        vim.api.nvim_buf_create_user_command(bufnr, "FlutterLog", function()
          require("snacks").terminal("flutter logs", {
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, {})

        -- Clear Flutter logs
        vim.api.nvim_buf_create_user_command(bufnr, "FlutterLogClear", function()
          vim.fn.system("flutter logs --clear")
          vim.notify("Flutter logs cleared", vim.log.levels.INFO)
        end, {})

        -- Pub commands
        vim.api.nvim_buf_create_user_command(bufnr, "FlutterPubGet", function()
          vim.notify("Running flutter pub get...", vim.log.levels.INFO)
          local output = vim.fn.system("flutter pub get")
          if vim.v.shell_error == 0 then
            vim.notify("Dependencies installed successfully", vim.log.levels.INFO)
          else
            vim.notify("Failed to install dependencies:\n" .. output, vim.log.levels.ERROR)
          end
        end, {})

        vim.api.nvim_buf_create_user_command(bufnr, "FlutterPubUpgrade", function()
          vim.notify("Running flutter pub upgrade...", vim.log.levels.INFO)
          local output = vim.fn.system("flutter pub upgrade")
          if vim.v.shell_error == 0 then
            vim.notify("Dependencies upgraded successfully", vim.log.levels.INFO)
          else
            vim.notify("Failed to upgrade dependencies:\n" .. output, vim.log.levels.ERROR)
          end
        end, {})

        -- Widget wrap helper
        vim.keymap.set("v", "<localleader>w", function()
          local start_row, start_col = unpack(vim.api.nvim_buf_get_mark(bufnr, "<"))
          local end_row, end_col = unpack(vim.api.nvim_buf_get_mark(bufnr, ">"))
          local lines = vim.api.nvim_buf_get_lines(bufnr, start_row - 1, end_row, false)

          -- Simple widget wrap with Container
          local indent = lines[1]:match("^%s*")
          vim.api.nvim_buf_set_lines(bufnr, start_row - 1, start_row - 1, false, { indent .. "Container(" })
          vim.api.nvim_buf_set_lines(bufnr, end_row + 1, end_row + 1, false, { indent .. "  child: " })
          vim.api.nvim_buf_set_lines(bufnr, end_row + 2, end_row + 2, false, { indent .. ")," })
        end, { buffer = bufnr, desc = "Wrap with Widget" })
      end,
    }))

    -- Go with comprehensive gopls settings
    lspconfig.gopls.setup(vim.tbl_extend("force", default_config, {
      cmd = { "gopls" },
      filetypes = { "go", "gomod", "gowork", "gotmpl" },
      root_dir = lspconfig.util.root_pattern("go.work", "go.mod", ".git"),
      settings = {
        gopls = {
          gofumpt = true,
          codelenses = {
            gc_details = false,
            generate = true,
            regenerate_cgo = true,
            run_govulncheck = true,
            test = true,
            tidy = true,
            upgrade_dependency = true,
            vendor = true,
          },
          hints = {
            assignVariableTypes = true,
            compositeLiteralFields = true,
            compositeLiteralTypes = true,
            constantValues = true,
            functionTypeParameters = true,
            parameterNames = true,
            rangeVariableTypes = true,
          },
          analyses = {
            fieldalignment = true,
            nilness = true,
            unusedparams = true,
            unusedwrite = true,
            useany = true,
            shadow = true,
            unusedvariable = true,
          },
          usePlaceholders = true,
          completeUnimported = true,
          staticcheck = true,
          directoryFilters = { "-.git", "-.vscode", "-.idea", "-.vscode-test", "-node_modules" },
          semanticTokens = true,
          templateExtensions = { "tpl", "tmpl", "gotmpl" },
          buildFlags = { "-tags=integration" },
        },
      },
      on_attach = function(client, bufnr)
        -- Enable inlay hints for Go
        if client.server_capabilities.inlayHintProvider then
          vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })
        end

        -- Go-specific keybindings using localleader
        local opts = { buffer = bufnr, silent = true }

        -- Code organization
        vim.keymap.set("n", "<localleader>i", function()
          vim.lsp.buf.code_action({
            context = { only = { "source.organizeImports" } },
            apply = true,
          })
        end, vim.tbl_extend("force", opts, { desc = "Organize Imports" }))

        -- Fill struct
        vim.keymap.set("n", "<localleader>fs", function()
          vim.lsp.buf.code_action({
            context = { only = { "refactor.rewrite" } },
            apply = true,
          })
        end, vim.tbl_extend("force", opts, { desc = "Fill struct" }))

        -- Generate test
        vim.keymap.set("n", "<localleader>gt", function()
          vim.lsp.buf.code_action({
            context = { only = { "source.generateTest" } },
            apply = true,
          })
        end, vim.tbl_extend("force", opts, { desc = "Generate test" }))

        -- Run go mod tidy
        vim.keymap.set("n", "<localleader>m", function()
          vim.lsp.buf.code_action({
            context = { only = { "source.fixAll" } },
            apply = true,
          })
          vim.notify("Running go mod tidy", vim.log.levels.INFO)
        end, vim.tbl_extend("force", opts, { desc = "Go mod tidy" }))

        -- Toggle inlay hints
        vim.keymap.set("n", "<localleader>h", function()
          vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled({ bufnr = bufnr }), { bufnr = bufnr })
        end, vim.tbl_extend("force", opts, { desc = "Toggle inlay hints" }))

        -- Run tests
        vim.keymap.set("n", "<localleader>t", function()
          local current_file = vim.fn.expand("%:p:h")
          require("snacks").terminal("go test -v ./...", {
            cwd = current_file,
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, vim.tbl_extend("force", opts, { desc = "Run tests" }))

        -- Run current file
        vim.keymap.set("n", "<localleader>r", function()
          local current_file = vim.fn.expand("%")
          require("snacks").terminal("go run " .. current_file, {
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, vim.tbl_extend("force", opts, { desc = "Run current file" }))

        -- Build
        vim.keymap.set("n", "<localleader>b", function()
          require("snacks").terminal("go build", {
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, vim.tbl_extend("force", opts, { desc = "Build project" }))
      end,
    }))

    -- Angular Language Server
    lspconfig.angularls.setup(vim.tbl_extend("force", default_config, {
      cmd = { "ngserver", "--stdio", "--tsProbeLocations", "", "--ngProbeLocations", "" },
      filetypes = { "typescript", "html", "typescriptreact", "typescript.tsx", "htmlangular" },
      root_dir = lspconfig.util.root_pattern("angular.json", ".git"),
      on_attach = function(client, bufnr)
        -- Angular-specific keybindings
        local opts = { buffer = bufnr, silent = true }

        -- Component navigation
        vim.keymap.set("n", "<localleader>gc", function()
          vim.lsp.buf.definition()
        end, vim.tbl_extend("force", opts, { desc = "Go to component" }))

        -- Template navigation
        vim.keymap.set("n", "<localleader>gt", function()
          vim.cmd("edit %:r.html")
        end, vim.tbl_extend("force", opts, { desc = "Go to template" }))

        vim.keymap.set("n", "<localleader>gs", function()
          vim.cmd("edit %:r.scss")
        end, vim.tbl_extend("force", opts, { desc = "Go to styles" }))

        vim.keymap.set("n", "<localleader>gT", function()
          vim.cmd("edit %:r.spec.ts")
        end, vim.tbl_extend("force", opts, { desc = "Go to test" }))
      end,
    }))

    -- Astro Language Server
    lspconfig.astro.setup(vim.tbl_extend("force", default_config, {
      cmd = { "astro-ls", "--stdio" },
      filetypes = { "astro" },
      root_dir = lspconfig.util.root_pattern("package.json", "tsconfig.json", "jsconfig.json", ".git"),
      init_options = {
        typescript = {
          tsdk = vim.fs.normalize("node_modules/typescript/lib")
        },
      },
      settings = {
        astro = {
          updateImportsOnFileMove = {
            enabled = true
          },
        },
        typescript = {
          globalPlugins = {
            {
              name = "@astrojs/ts-plugin",
              location = vim.fs.normalize("node_modules/@astrojs/ts-plugin"),
              enableForWorkspaceTypeScriptVersions = true,
            },
          },
        },
      },
      on_attach = function(client, bufnr)
        -- Astro-specific keybindings
        local opts = { buffer = bufnr, silent = true }

        -- Format with prettier
        vim.keymap.set("n", "<localleader>f", function()
          vim.lsp.buf.format({ async = true })
        end, vim.tbl_extend("force", opts, { desc = "Format Astro file" }))

        -- Build
        vim.keymap.set("n", "<localleader>b", function()
          require("snacks").terminal("npm run build", {
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, vim.tbl_extend("force", opts, { desc = "Build Astro project" }))

        -- Dev server
        vim.keymap.set("n", "<localleader>d", function()
          require("snacks").terminal("npm run dev", {
            win = {
              position = "bottom",
              height = 0.3,
            },
          })
        end, vim.tbl_extend("force", opts, { desc = "Start dev server" }))
      end,
    }))

    -- Tailwind CSS Language Server (useful for both Angular and Astro)
    lspconfig.tailwindcss.setup(vim.tbl_extend("force", default_config, {
      cmd = { "tailwindcss-language-server", "--stdio" },
      filetypes = { "html", "css", "scss", "javascript", "javascriptreact", "typescript", "typescriptreact", "astro", "vue", "svelte" },
      root_dir = lspconfig.util.root_pattern("tailwind.config.js", "tailwind.config.cjs", "tailwind.config.mjs", "tailwind.config.ts", ".git"),
      settings = {
        tailwindCSS = {
          validate = true,
          classAttributes = { "class", "className", "class:list", "classList", "ngClass" },
          lint = {
            cssConflict = "warning",
            invalidApply = "error",
            invalidConfigPath = "error",
            invalidScreen = "error",
            invalidTailwindDirective = "error",
            invalidVariant = "error",
            recommendedVariantOrder = "warning",
          },
          experimental = {
            classRegex = {
              -- Support for clsx/cn functions
              { "clsx\\(([^)]*)\\)", "[\"'`]([^\"'`]*).*?[\"'`]" },
              { "cn\\(([^)]*)\\)", "[\"'`]([^\"'`]*).*?[\"'`]" },
              -- Angular class bindings
              { "\\[class\\]=\\\"([^\"]*)\\\"", "([^\"]*)" },
              { "\\[ngClass\\]=\\\"([^\"]*)\\\"", "([^\"]*)" },
            },
          },
        },
      },
    }))

    -- HTML Language Server (enhanced for Angular templates)
    lspconfig.html.setup(vim.tbl_extend("force", default_config, {
      cmd = { "vscode-html-language-server", "--stdio" },
      filetypes = { "html", "htmlangular" },
      root_dir = lspconfig.util.root_pattern("package.json", ".git"),
      init_options = {
        configurationSection = { "html", "css", "javascript" },
        embeddedLanguages = {
          css = true,
          javascript = true,
        },
        provideFormatter = true,
      },
      settings = {
        html = {
          format = {
            enable = true,
            wrapLineLength = 120,
            unformatted = "",
            contentUnformatted = "pre,code,textarea",
            indentInnerHtml = false,
            preserveNewLines = true,
            maxPreserveNewLines = 2,
            indentHandlebars = false,
            endWithNewline = true,
            extraLiners = "",
            wrapAttributes = "auto",
          },
          validate = {
            scripts = true,
            styles = true,
          },
        },
      },
    }))

    -- CSS/SCSS Language Server
    lspconfig.cssls.setup(vim.tbl_extend("force", default_config, {
      cmd = { "vscode-css-language-server", "--stdio" },
      filetypes = { "css", "scss", "less" },
      root_dir = lspconfig.util.root_pattern("package.json", ".git"),
      settings = {
        css = {
          validate = true,
          lint = {
            unknownAtRules = "ignore",
          },
        },
        scss = {
          validate = true,
          lint = {
            unknownAtRules = "ignore",
          },
        },
      },
    }))

    -- Emmet Language Server
    lspconfig.ls_emmet.setup(vim.tbl_extend("force", default_config, {
      cmd = { "ls_emmet", "--stdio" },
      filetypes = { "html", "css", "scss", "javascript", "typescript", "vue", "svelte" },
      root_dir = lspconfig.util.root_pattern("package.json", ".git"),
      settings = {
        html = {
          preferences = {
            -- Enable emmet abbreviation expansion
            expandAbbreviation = true,
          },
        },
      },
    })

    -- Elixir Expert LSP (Official Elixir Language Server)
    -- Using custom Expert installation path
    local expert_path = vim.fn.expand("~/.tools/expert/expert")
    if vim.fn.executable(expert_path) == 1 then
      -- Register custom config for Expert if not already defined
      local configs = require('lspconfig.configs')
      if not configs.expert then
        configs.expert = {
          default_config = {
            cmd = { expert_path, "server" },
            filetypes = { "elixir", "eex", "heex", "surface" },
            root_dir = lspconfig.util.root_pattern("mix.exs", ".git"),
            single_file_support = true,
            init_options = {
              experimental = {
                completions = {
                  enable = true
                }
              }
            },
            settings = {},
          },
        }
      end
      lspconfig.expert.setup(vim.tbl_extend("force", default_config, {
        on_attach = function(client, bufnr)
          -- Enable completion triggered by <c-x><c-o>
          vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')
        end,
      }))
    else
      -- Fallback to ElixirLS if Expert not found
      print("Expert LSP not found at " .. expert_path .. ", falling back to ElixirLS")
      lspconfig.elixirls.setup(default_config)
    end
  end,
}
